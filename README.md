# 一致性哈希算法实现与对比

本项目实现了多种一致性哈希算法，并对它们进行了全面的测试和对比分析。

## 实现的算法

1. **直接哈希取模 (Mod Hash)**
2. **哈希环 (Hash Ring)**
3. **跳跃一致性哈希 (Jump Consistent Hash)**
4. **Maglev哈希 (Maglev Consistent Hash)**
5. **Rendezvous哈希 (Rendezvous Consistent Hash)**
6. **AnchorHash**
7. **DxHash**
8. **Multi-Probe一致性哈希 (Multi-Probe Consistent Hash)**

<details>

<summary>测试结果含义解释</summary>

## 测试结果含义解释

### 分布均匀性测试结果解释

分布均匀性测试衡量的是当大量键被分配到固定数量的节点时，每个节点被分配到的键数量是否接近平均值。我们使用标准差来衡量分布均匀性：

- **标准差越小**：表示各节点被分配到的键数量越接近平均值，分布越均匀
- **标准差越大**：表示某些节点被分配到的键数量远高于或低于平均值，分布不均匀

例如，在100个节点、100,000个键的测试中，平均每个节点应该分配到1000个键：
- 跳跃一致性哈希的标准差为25.34，表示大部分节点分配到的键数量在975到1025之间
- AnchorHash的标准差为8954.69，表示节点间的分配极不均匀

值得注意的是，Multi-Probe一致性哈希随着探针数量从5增加到21，分布均匀性显著改善（标准差从362.18降到144.83）。

### 性能测试结果解释

性能测试衡量的是算法处理单个键查询的速度：

- **时间越短**：表示算法查询速度越快，性能越好
- **时间越长**：表示算法查询速度越慢，性能越差

例如，在1000个节点、100,000个键的测试中：
- Maglev哈希处理100,000次查询仅需12.42毫秒
- Multi-Probe一致性哈希(k=21)处理同样数量的查询需要超过4分钟

随着Multi-Probe一致性哈希的探针数量从5增加到21，查询时间也从1分钟增加到4分钟以上，这是由于需要计算更多的哈希值。

### 重映射测试结果解释

重映射测试衡量的是当系统中增加新节点时，有多少比例的键需要重新分配到不同的节点：

- **重映射比例越低**：表示系统扩展时对现有服务的影响越小
- **重映射比例越高**：表示系统扩展时对现有服务的影响越大

例如，在1000个初始节点新增10个节点的测试中：
- AnchorHash只有0.47%的键需要重映射
- 直接哈希取模几乎所有的键(98.97%)都需要重映射

Multi-Probe一致性哈希随着探针数量增加，重映射比例略有改善（从1.00%降到0.99%）。

</details>

<details>

<summary>基准测试各项数据含义解释</summary>

## 基准测试各项数据含义解释

基准测试是Go语言中用于测量代码性能的标准方法。以下是对各项数据的详细解释：

### 1. 迭代次数（Iterations）
格式：`数字`（例如：10207114）
- 表示在测试期间执行的操作次数
- 数字越大表示算法执行速度越快
- 例如：BenchmarkModHash-8执行了10,207,114次操作

### 2. 每次操作时间（ns/op）
格式：`数字 ns/op`（例如：112.8 ns/op）
- 表示每个操作的平均执行时间，单位为纳秒（nanoseconds）
- 数字越小表示算法执行速度越快
- 例如：ModHash每个操作平均耗时112.8纳秒

### 3. 每次操作内存分配（B/op）
格式：`数字 B/op`（例如：15 B/op）
- 表示每个操作平均分配的内存量，单位为字节（Bytes）
- 数字越小表示内存效率越高
- 例如：MaglevHash每个操作平均分配15字节内存

### 4. 每次操作内存分配次数（allocs/op）
格式：`数字 allocs/op`（例如：1 allocs/op）
- 表示每个操作平均进行的内存分配次数
- 数字越小表示内存分配效率越高
- 例如：MaglevHash每个操作平均进行1次内存分配

### 5. 并发标记（-8）
格式：`BenchmarkName-数字`（例如：BenchmarkModHash-8）
- 表示测试运行时使用的并发数（GOMAXPROCS）
- 通常与CPU核心数相关

</details>

## 测试结果

### 分布均匀性测试

测试条件：100个节点，100,000个键

| 算法                 | 标准差  | 评价 |
|----------------------|---------|------|
| 跳跃一致性哈希       | 25.34   | 最优 |
| 直接哈希取模         | 29.18   | 优秀 |
| Rendezvous哈希       | 32.13   | 良好 |
| Maglev哈希           | 35.74   | 良好 |
| Multi-Probe CH(k=21) | 144.83  | 一般 |
| Multi-Probe CH(k=5)  | 362.18  | 较差 |
| DxHash               | 543.58  | 较差 |
| 哈希环               | 83.59   | 一般 |
| AnchorHash           | 8954.69 | 很差 |

### 添加节点时的重映射测试

测试条件：1000个初始节点，新增10个节点，100,000个键

| 算法                 | 重映射键数 | 重映射比例 | 评价 |
|----------------------|------------|------------|------|
| AnchorHash           | 466        | 0.47%      | 最优 |
| 跳跃一致性哈希       | 969        | 0.97%      | 优秀 |
| Rendezvous哈希       | 977        | 0.98%      | 优秀 |
| Multi-Probe CH(k=21) | 989        | 0.99%      | 优秀 |
| Multi-Probe CH(k=5)  | 1003       | 1.00%      | 优秀 |
| 哈希环               | 1078       | 1.08%      | 良好 |
| DxHash               | 1194       | 1.19%      | 良好 |
| Maglev哈希           | 3418       | 3.42%      | 一般 |
| 直接哈希取模         | 98971      | 98.97%     | 很差 |

### 查询性能测试

测试条件：1000个节点，100,000个键

| 算法                 | 查询时间 | 评价 |
|----------------------|----------|------|
| Maglev哈希           | 12.42ms  | 最优 |
| 直接哈希取模         | 10.60ms  | 优秀 |
| 跳跃一致性哈希       | 17.39ms  | 优秀 |
| 哈希环               | 23.27ms  | 良好 |
| AnchorHash           | 45.39ms  | 良好 |
| DxHash               | 103.29ms | 一般 |
| Rendezvous哈希       | 11.51s   | 很差 |
| Multi-Probe CH(k=5)  | 1m1.77s  | 极差 |
| Multi-Probe CH(k=21) | 4m22.96s | 极差 |

### 基准测试结果

测试条件：1000个节点

| 算法                 | 每次操作时间  | 每次操作内存分配              | 评价 |
|----------------------|---------------|-------------------------------|------|
| Maglev哈希           | 128.2 ns/op   | 15 B/op (1 allocs/op)         | 最优 |
| 直接哈希取模         | 112.8 ns/op   | 0 B/op (0 allocs/op)          | 优秀 |
| 跳跃一致性哈希       | 200.1 ns/op   | 0 B/op (0 allocs/op)          | 优秀 |
| 哈希环               | 223.1 ns/op   | 0 B/op (0 allocs/op)          | 良好 |
| AnchorHash           | 416.0 ns/op   | 15 B/op (1 allocs/op)         | 良好 |
| DxHash               | 959.2 ns/op   | 191 B/op (9 allocs/op)        | 一般 |
| Rendezvous哈希       | 113918 ns/op  | 0 B/op (0 allocs/op)          | 很差 |
| Multi-Probe CH(k=5)  | 624716 ns/op  | 76059 B/op (5005 allocs/op)   | 极差 |
| Multi-Probe CH(k=21) | 2571089 ns/op | 319368 B/op (21021 allocs/op) | 极差 |

## 算法特点总结

### 1. 直接哈希取模（Mod Hash）
- **优点**：
  - 实现简单
  - 查询性能好（O(1)）
  - 内存占用小
- **缺点**：
  - 添加节点时重映射比例极高（98.97%）
  - 分布均匀性一般
- **适用场景**：节点数量固定或变化很少的场景

### 2. 哈希环（Hash Ring）
- **优点**：
  - 实现简单，概念清晰
  - 通过虚拟节点可调节分布均匀性
- **缺点**：
  - 查询性能一般（O(log N)）
  - 分布均匀性一般
- **适用场景**：对性能要求不高，实现简单优先的场景

### 3. 跳跃一致性哈希（Jump Consistent Hash）
- **优点**：
  - 内存占用极小，无需存储额外数据结构
  - 查询性能好
  - 分布均匀性最好
  - 添加节点时重映射最少
- **缺点**：
  - 只能在尾部增删节点
- **适用场景**：节点变化较少，且主要在尾部操作的场景

### 4. Maglev哈希
- **优点**：
  - 查询性能最好（O(1)）
  - 分布均匀性良好
- **缺点**：
  - 需要预先计算查找表，内存占用大
  - 添加节点时重映射比例较高
  - 表重建耗时较长
- **适用场景**：查询频率高，对查询性能要求极高的场景

### 5. Rendezvous哈希
- **优点**：
  - 分布均匀性好
  - 可以在任意位置增删节点
  - 添加节点时重映射较少
- **缺点**：
  - 查询性能最差（O(N)）
- **适用场景**：节点数量不多，对分布均匀性要求高，查询频率不高的场景

### 6. AnchorHash
- **优点**：
  - 添加节点时重映射最少（0.47%）
  - 删除节点只影响直接映射到该节点的key
- **缺点**：
  - 分布均匀性差
  - 查询性能一般
- **适用场景**：对重映射要求极高的场景

### 7. DxHash
- **优点**：
  - 添加节点时重映射较少
  - 支持动态扩容
- **缺点**：
  - 分布均匀性较差
  - 查询性能一般
  - 实现复杂度较高
- **适用场景**：需要动态扩容且对重映射有一定要求的场景

### 8. Multi-Probe一致性哈希
- **优点**：
  - 可通过调整探针数量平衡分布均匀性和重映射
  - 添加节点时重映射较少
- **缺点**：
  - 查询性能极差
  - 内存占用大
  - 随着探针数量增加，性能显著下降
- **适用场景**：
  - 对分布均匀性和重映射要求高，但查询频率不高的场景
  - k=5适用于一般需求，k=21适用于对分布均匀性要求极高的场景

## 性能综合对比表

| 算法                 | 查询性能 | 分布均匀性 | 重映射比例 | 内存占用 |
|----------------------|----------|------------|------------|----------|
| 直接哈希取模         | 最好     | 一般       | 最高       | 最低     |
| 跳跃一致性哈希       | 好       | 最好       | 最低       | 最低     |
| Maglev哈希           | 最好     | 好         | 一般       | 高       |
| Rendezvous哈希       | 最差     | 好         | 低         | 最低     |
| 哈希环               | 一般     | 差         | 一般       | 低       |
| AnchorHash           | 一般     | 最差       | 最低       | 中等     |
| DxHash               | 一般     | 差         | 一般       | 中等     |
| Multi-Probe CH(k=5)  | 差       | 较差       | 一般       | 高       |
| Multi-Probe CH(k=21) | 最差     | 一般       | 一般       | 最高     |

## 应用建议

根据测试结果和算法特点，选择建议如下：

1. **查询性能优先**：选择直接哈希取模或Maglev哈希
2. **最优分布均匀性**：选择跳跃一致性哈希
3. **最小化重映射**：选择AnchorHash或跳跃一致性哈希
4. **平衡各方面需求**：选择哈希环算法，并适当调整虚拟节点数
5. **动态扩容需求**：选择DxHash
6. **对重映射极其敏感**：选择AnchorHash
7. **节点数量相对固定**：选择直接哈希取模
8. **对分布均匀性要求极高**：选择Multi-Probe一致性哈希(k=21)，但需接受其极差的查询性能

## 使用方法

```bash
# 运行测试
go run cmd/main.go

# 运行基准测试
go test -bench=. -benchmem ./tests/

# 查看详细结果
cat results/test_results_final.txt
cat results/benchmark_results_final.txt
```

## 结论

不同的一致性哈希算法在不同维度上各有优劣。在实际应用中，应根据具体需求选择最适合的算法：

- 对于高性能要求的场景（如CDN、负载均衡），推荐使用Maglev哈希
- 对于节点频繁变化且对重映射敏感的场景，推荐使用AnchorHash或跳跃一致性哈希
- 对于对分布均匀性要求极高的场景，可以考虑使用Multi-Probe一致性哈希，但需要权衡其查询性能
- 对于简单实现且节点变化不频繁的场景，可以使用哈希环

选择合适的算法需要在查询性能、分布均匀性、重映射比例和内存占用等多个因素之间进行权衡。Multi-Probe一致性哈希展示了在一致性哈希算法中可以通过调整参数（探针数量）来平衡不同指标的特性。
